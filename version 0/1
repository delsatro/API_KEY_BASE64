#!/bin/bash

# --- БЛОК 1: Проверка и настройки ---
echo "Запуск скрипта для обработки секретных данных..."

# Проверяем наличие закодированной переменной окружения
if [ -z "$API_KEY_BASE64" ]; then
  echo "Ошибка: Переменная API_KEY_BASE64 не установлена."
  exit 1
fi

# Имя файла для временного хранения ключа
SECRET_FILE="decoded_api_key.txt"

# --- БЛОК 2: Декодирование Base64 ---
echo "Декодирование ключа Base64..."

# Используем команду base64 -d (decode) для преобразования строки обратно в ключ.
# Примечание: на macOS используется 'base64 -D', на Linux 'base64 -d'.
# В окружении GitHub Actions обычно используется Linux-версия.
# Результат сохраняем во временный файл.

echo "$API_KEY_BASE64" | base64 -d > "$SECRET_FILE"

# Проверяем, успешно ли декодирование
if [ $? -ne 0 ]; then
  echo "Ошибка: Не удалось декодировать строку Base64."
  rm -f "$SECRET_FILE" # Удаляем файл в случае ошибки
  exit 1
fi

# Загружаем декодированный ключ в переменную для использования
API_KEY=$(cat "$SECRET_FILE")

# --- БЛОК 3: Использование ключа (пример) ---
echo "Ключ успешно декодирован. Использование в команде..."

# ПРИМЕР: Использование ключа в команде cURL для доступа к API
# Важно: $API_KEY НЕ выводится в логи!
curl -H "Authorization: Bearer $API_KEY" https://api.example.com/data

# --- БЛОК 4: Очистка (КРИТИЧЕСКИ ВАЖНО ДЛЯ БЕЗОПАСНОСТИ!) ---
echo "Завершение работы и удаление временного файла..."

# Немедленное и безопасное удаление файла, содержащего секретный ключ.
# Флаг -f (force) предотвращает ошибки, если файл не существует.
rm -f "$SECRET_FILE"

echo
